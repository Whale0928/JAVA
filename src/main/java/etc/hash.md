# Map — Hash Table

## Map

- key - valeu으로 이루어진 컬렉션
- 여러 방면에서 사용 가능하다
    - 주소록 ( 이름 - 주소 )
    - 전화번호부 (이름 - 번호)
    - 투표 ( 번호 - 주제 )

## Map의 구현체

- [**Hash Table**](https://www.notion.so/Map-Hash-Table-9ae5f9014ec94279960b7497cff84e2c)
- Tree - based

### Hash Table

- 배열 과 해시 함수 ( [Hash Function](https://www.notion.so/Map-Hash-Table-9ae5f9014ec94279960b7497cff84e2c) ) 을 사용해 map을 구현한 자료 구조
- 상수시간으로 데이터에 접근해 “매우 빠르다”

### Hash Function

- 임의의 크기를 가지는 타입의 데이터를 고정된 크기를 가지는 타입의 데이터로 변환하는 함수
- ( hash Table )임의의 데이터를 정수( `Integer` )로 변환하는 함수

“특정한한 문자열” ⇒ Hash_Function ⇒ 200013 ( Integer_data )

- “특정한한 문자열”의 해쉬는 200013가 된다

회원객체 정보        ⇒ Hash_Function ⇒ 132013 ( Integer_data )

- 회원객체의 해쉬는 132013가 된다.

hash는 hash_function을 통해 만들어진 임의의 정수를 hash값이라고 한다

## Hash Table 동작 방식

`.put(”010-1234-1234”, “회원명”)`

- 해쉬 함수를 통해 key인 `”010-1234-1234”` 의 해쉬는 정수형태로 가지게 된다  (202)
- 이 값을 `%8` 하여 모듈러 연산을 한다
- capacity라는 8칸의 배열의  2번 버킷에 `“회원명”` 과 `“010-1234-1234”` 를 저장하게 된다
    - 한칸을 bucket 혹은 slot이라고 한다.
    - 회원명만 저장시에는 모듈러 연산을 통해 중복 값이 나올떄 중복 조회되는 문제가 발생한다.


`.get(”010-1234-1234”)`

- 해쉬값을 프로그램이 종료전까지 매번 동일하기 때문에 해쉬값이 202가 나오게 된다.
    - 보안상약점이기도 하다
- 다시 이 값을 모듈러 연산하여 2번 인덱스를 찾게 된다.
- 2번 버킷에 저장되어 있는 값들중 키와 equals 연산을 통해 같이 저장된 value를 찾아올수 있게 된다.

---

### Hash Collision

### key 는 다르지만 hash값은 같을 때

- “010-1234-1234” ⇒ 202 ⇒ %8 ⇒ 2
- “010-0000-1111”  ⇒ 402 ⇒ %8 ⇒ 2
- 해쉬 범위를 계속 줄이기 때문에  피할 수 없는 문제
    - 해쉬 값이 최대한 균등하게 분포되도록 구현해야 한다.

### key와 hash 모두 다르지만 hash%map_capa결과가 같을때.

## 해결 방법

### Open addression

( linear probing )

- 해쉬 인덱스가 2번이 나왔지만 2번인덱스에 이미 값이 있는 경우
- 비어있는 바로 다음 버킷에 저장한다. ( 3번 인덱스 )

- `get()` 수행 시 모듈러 연산을 통해 나온 인덱스 위치에 값이 없어도
- 다음 버킷에 저장되어 있는지 탐색하는 동작이 수행된다.

- `.delete()` 할 경우 해당 인덱스를 지운 후 2번 인덱스지만 다음 노드에 저장된 값이 있을 수 있기 때문에
- 원래 있는 위치에 더미를 위치 하거나 이후 노드들을 한칸씩 당기는 작업이 필요하다

<aside>
❕ 자바는 전체 케파시티의 4/3 이상 75%이상 데이터가 들어게 되는 경우 
자동으로 사이즈를 2배로 늘려준다

이때에는 기본적으로 해쉬테이블에 저장되면서 해쉬값도 같이 저장되는데
2배로 사이즈를 늘리게 되면 자동으로 저장되 있던 해쉬값을 다시 모듈러 연산(`8% ⇒ 16%`) 후
배치한다 이러한 과정 중 다시 인덱스가 변경하기도 한다.

</aside>

### separate chaining

( 세퍼라이트 체이닝 )

- 버킷(슬롯)을 Linked List 형태로 관리한다
- 해쉬 인덱스가 2번이 나왔지만 2-1번인덱스에 이미 값이 있는 경우
  다음 노드인 2-2번 인덱스에 저장하게 한다.
- 이때 키가 값으면 덮어씌우게 된다.

| 1   |                     |                     |                     |
|-----|---------------------|---------------------|---------------------|
| 2   | 010-1234-1234 , 홍길동 | 010-4421-1421 , 김개똥 | 010-3211-1234 , 홍길동 |
| 3   |                     |                     |                     |

- key을 통해 찾을때는 해당 Linked List을 전부 순차적으로 접근해 찾는다
    - 010-1234-1234 ⇒ 010-4421-1421 ⇒ 010-3211-1234
- `containsValue(”홍길동”)` 의 경우 모든 테이블을 순차적으로 탐색한다.
- delete또한 key을 해쉬함수를 통해 해쉬값을 모듈러 연산 후 찾아 지운다.

---

|                                | C / Python 의 dictionary                                                | Java HashMap                                                             |
|--------------------------------|------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 구현                             | hash table을 사용한다                                                       | 동일                                                                       |
| 데이터 접근 시간                      | 모든 데이터를 상수 시간에 접근                                                      | 동일                                                                       |
| 삽입 / 삭제 시간                     | 모든 데이터를 상수 시간에 접근                                                      | 동일                                                                       |
| 해쉬 충돌 해결 방법                    | https://www.notion.so/Open-addression-539c4cdf8d834efea3932d1b7a7a9e3a | https://www.notion.so/separate-chaining-a439a7d599b04e618e60f9c408b5054e |
| default initial capa(최초 맵 사이즈) | 8                                                                      | 16                                                                       |
| resize 타이밍                     | capa가 3/2이상 데이터 존재 시                                                   | capa의 4/3 이상의 데이터 존재시                                                    |
| resize 규모                      | 4x or 2x                                                               | 2x                                                                       |
| shrink 타이밍(capa를 다시 줄여줄때)      | dummy 데이터 > 유효 데이터 일떄에                                                 | LinkedList라 필요없다                                                         |
| hash table capa(항상 2승)         | power of 2                                                             | power of 2                                                               |
- 최악의 상황시 시간이 오래 걸림 ( 모든 방식에 Hash Collision 발생)